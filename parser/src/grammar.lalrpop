use super::lexer;
use super::ast;
use errors;

grammar<>;
extern {
    type Location = usize;
    type Error = errors::LexicalError;

    enum lexer::Token<> {
        "ident" => lexer::Token::Identifier(<String>),
        "string" => lexer::Token::StringLiteral(<String>),
        "int" => lexer::Token::IntLiteral(<i64>),
        "float" => lexer::Token::FloatLiteral(<f64>),
        "return" => lexer::Token::Return,
    
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "for" => lexer::Token::For,
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "let" => lexer::Token::Let,
        "fun" => lexer::Token::Fun,
        
	    "(" => lexer::Token::ParOpen,
        ")" => lexer::Token::ParClose,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "/" => lexer::Token::Slash,
        "," => lexer::Token::Comma,
        "." => lexer::Token::Dot,
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "?" => lexer::Token::Question,
        "!" => lexer::Token::ExclMark,
        "*" => lexer::Token::Star,
        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "!=" => lexer::Token::NotEqual,
        "==" => lexer::Token::VeryEqual,
        "=" => lexer::Token::Equal,        //
        ">" => lexer::Token::Greater,      //
        ">=" => lexer::Token::GreaterEqual, //
        "<" => lexer::Token::Less,         //
        "<=" => lexer::Token::LessEqual,    //
    }
    
}

// Comma separated 
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program: ast::Program = {
    <items: (GpuFunction)*> => ast::Program{items}
}

pub GpuFunction: ast::GpuFunction = {
    "fun" <i:"ident"> "(" <args:Comma<Definition>> ")" "{" <s:"string"> "}" => ast::GpuFunction{ name:i, code: s, arguments: args}
}

Definition: (ast::Variable, ast::Type) = {
    <i1:"ident"> ":" <i2:"ident"> => (ast::Variable::new(i1), ast::Type::new(i2))
}

Literal: ast::Literal = {
    <l:@L> <val:"int"> <r:@R>=> ast::Literal::Int(ast::Spanned::new(val, lexer::span(l,r))),
    <l:@L> <val:"float"> <r:@R> => ast::Literal::Float(ast::Spanned::new(val, lexer::span(l,r))),
    <l:@L> <val:"string"> <r:@R> => ast::Literal::String(ast::Spanned::new(val, lexer::span(l,r))),

}
